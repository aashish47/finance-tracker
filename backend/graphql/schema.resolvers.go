package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"sort"
	"time"

	"github.com/aashish47/finance-tracker/backend/graphql/model"
	"github.com/aashish47/finance-tracker/backend/utils"
	"gorm.io/gorm"
)

// Transactions is the resolver for the transactions field.
func (r *categoryResolver) Transactions(ctx context.Context, obj *model.Category, rangeArg *model.RangeInput) ([]*model.Transaction, error) {
	if obj.Transactions == nil {
		fmt.Println("Category Transactions: ", time.Now().Format("15:04:05"))

		transactions := []*model.Transaction{}
		query := r.DB.Where("category_id = ?", obj.ID)

		if rangeArg != nil {
			query.Where("date Between ? AND ?", rangeArg.StartDate, rangeArg.EndDate)
		}

		if err := query.Preload("Category").Find(&transactions).Error; err != nil {
			return nil, err
		}

		obj.Transactions = transactions
	}
	return obj.Transactions, nil
}

// Total is the resolver for the total field.
func (r *categoryResolver) Total(ctx context.Context, obj *model.Category, rangeArg *model.RangeInput) (*float64, error) {
	if obj.Total == nil {
		fmt.Println("Category Total: ", time.Now().Format("15:04:05"))

		var total float64
		query := r.DB.Model(&model.Transaction{}).Where("category_id = ?", obj.ID)

		if rangeArg != nil {
			query.Where("date Between ? AND ?", rangeArg.StartDate, rangeArg.EndDate)
		}

		if err := query.Select("COALESCE(SUM(amount), 0)").Scan(&total).Error; err != nil {
			return nil, err
		}

		obj.Total = &total
	}
	return obj.Total, nil
}

// CreateTransaction is the resolver for the createTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, input model.TransactionInput) (*model.Transaction, error) {
	userId, err := utils.GetUserIDFromContext(ctx)

	if err != nil {
		return nil, err
	}

	newTransaction := &model.Transaction{
		Item:       input.Item,
		CategoryID: input.CategoryID,
		IsIncome:   input.IsIncome,
		Date:       input.Date,
		Amount:     input.Amount,
		UserId:     userId,
	}

	if err := r.DB.Create(newTransaction).Error; err != nil {
		return nil, err
	}

	return newTransaction, nil
}

// UpdateTransaction is the resolver for the updateTransaction field.
func (r *mutationResolver) UpdateTransaction(ctx context.Context, id int, input model.UpdateTransactionInput) (*model.Transaction, error) {
	transaction := model.Transaction{}

	if err := r.DB.First(&transaction, id).Error; err != nil {
		return nil, err
	}

	if input.CategoryID != nil {
		transaction.CategoryID = *input.CategoryID
	}

	if input.Amount != nil {
		transaction.Amount = *input.Amount
	}
	if input.Date != nil {
		transaction.Date = *input.Date
	}
	if input.IsIncome != nil {
		transaction.IsIncome = *input.IsIncome
	}
	if input.Item != nil {
		transaction.Item = *input.Item
	}

	if err := r.DB.Save(&transaction).Error; err != nil {
		return nil, err
	}

	return &transaction, nil
}

// DeleteTransaction is the resolver for the deleteTransaction field.
func (r *mutationResolver) DeleteTransaction(ctx context.Context, id int) (*model.Transaction, error) {
	transaction := model.Transaction{}

	if err := r.DB.Where("id = ?", id).First(&transaction).Error; err != nil {
		return nil, err
	}

	deletedTransaction := transaction
	if err := r.DB.Delete(&transaction).Error; err != nil {
		return nil, err
	}
	return &deletedTransaction, nil
}

// Transactions is the resolver for the Transactions field.
func (r *queryResolver) Transactions(ctx context.Context, rangeArg *model.RangeInput) ([]*model.Transaction, error) {
	fmt.Println("Transactions: ", time.Now().Format("15:04:05"))

	userId, err := utils.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	transactions := []*model.Transaction{}
	query := r.DB.Where("user_id = ?", userId)

	if rangeArg != nil {
		query.Where("date Between ? AND ?", rangeArg.StartDate, rangeArg.EndDate)
	}

	query = query.Order("date DESC")

	// Modify the preload to include the total for each category, considering the date range
	// query = query.Preload("Category", func(db *gorm.DB) *gorm.DB {
	// 	if rangeArg != nil {
	// 		// If rangeArg is provided, apply date filter to the total subquery
	// 		return db.Select("id, name, (SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE category_id = categories.id AND date >= ? AND date <= ?) AS total", rangeArg.StartDate, rangeArg.EndDate)
	// 	} else {
	// 		// If rangeArg is nil, calculate total without date filter
	// 		return db.Select("id, name, (SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE category_id = categories.id) AS total")
	// 	}
	// }).Preload("Category.Transactions", func(db *gorm.DB) *gorm.DB {
	// 	if rangeArg != nil {
	// 		// Apply date filter to the transactions preload for each category
	// 		return db.Where("date >= ? AND date <= ?", rangeArg.StartDate, rangeArg.EndDate)
	// 	} else {
	// 		// Don't apply any date filter if rangeArg is nil
	// 		return db
	// 	}
	// })
	if err := query.Preload("Category").Find(&transactions).Error; err != nil {
		return nil, err
	}

	return transactions, nil
}

// Transaction is the resolver for the Transaction field.
func (r *queryResolver) Transaction(ctx context.Context, id int) (*model.Transaction, error) {
	userId, err := utils.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	transaction := model.Transaction{}

	if err := r.DB.Preload("Category").Where("id = ? AND user_id = ?", id, userId).First(&transaction).Error; err != nil {
		return nil, err
	}

	return &transaction, nil
}

// TransactionsByMonth is the resolver for the TransactionsByMonth field.
func (r *queryResolver) TransactionsByMonth(ctx context.Context, year int) ([]*model.MonthSummary, error) {
	fmt.Println("TransactionsByMonth: ", time.Now().Format("15:04:05"))
	userId, err := utils.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Query to group transactions by month and calculate the total for each month
	var groupedTotals []struct {
		Month int     `gorm:"column:month"`
		Total float64 `gorm:"column:total"`
	}

	if err := r.DB.
		Model(&model.Transaction{}).
		Select("EXTRACT(MONTH FROM date) AS month, SUM(amount) AS total").
		Where("user_id = ? AND EXTRACT(YEAR FROM date) = ?", userId, year).
		Group("month").
		Order("month ASC").
		Scan(&groupedTotals).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch grouped totals: %w", err)
	}

	// Query to group transactions by month and category, including the transactions
	var groupedByMonthCategoryAndTransactions []struct {
		Month         int               `gorm:"column:month"`
		CategoryID    int               `gorm:"column:category_id"`
		CategoryName  string            `gorm:"column:category_name"`
		CategoryTotal float64           `gorm:"column:category_total"`
		TransactionID int               `gorm:"column:transaction_id"`
		Transaction   model.Transaction `gorm:"embedded"`
	}
	err = r.DB.
		Model(&model.Transaction{}).
		Select(`EXTRACT(MONTH FROM date) AS month, 
                transactions.category_id, 
                (SELECT name FROM categories WHERE id = transactions.category_id) AS category_name, 
                SUM(transactions.amount) AS category_total, 
                transactions.id AS transaction_id, 
                transactions.*`).
		Joins("LEFT JOIN categories ON categories.id = transactions.category_id").
		Where("transactions.user_id = ? AND EXTRACT(YEAR FROM transactions.date) = ?", userId, year).
		Group("month, transactions.category_id, transactions.id, categories.id").
		Order("month ASC, transactions.category_id ASC").
		Scan(&groupedByMonthCategoryAndTransactions).Error

	if err != nil {
		return nil, fmt.Errorf("failed to fetch grouped data by month, category, and transactions: %w", err)
	}

	// Map to organize categories with transactions by month
	monthCategoryMap := make(map[int]map[int]*model.Category)
	for _, group := range groupedByMonthCategoryAndTransactions {
		// Initialize category map for the month if not already done
		if _, exists := monthCategoryMap[group.Month]; !exists {
			monthCategoryMap[group.Month] = make(map[int]*model.Category)
		}

		// Initialize the category if it doesn't already exist in the map
		category, exists := monthCategoryMap[group.Month][group.CategoryID]
		if !exists {
			total := group.CategoryTotal
			category = &model.Category{
				ID:    group.CategoryID,
				Name:  group.CategoryName,
				Total: &total,
			}
			monthCategoryMap[group.Month][group.CategoryID] = category
		} else {
			*category.Total += group.CategoryTotal
		}

		// Add the transaction to the category
		transaction := group.Transaction
		transaction.Category = &model.Category{ // Preload Category for each transaction
			ID:   group.CategoryID,
			Name: group.CategoryName,
		}
		category.Transactions = append(category.Transactions, &transaction)

	}

	// Prepare the final MonthSummary list
	monthSummaries := make([]*model.MonthSummary, 12)
	groupedTotalsMap := make(map[int]*float64)
	for _, group := range groupedTotals {
		total := group.Total
		groupedTotalsMap[group.Month] = &total
	}

	for month := 1; month <= 12; month++ {
		// Convert the category map for this month into a slice
		categories := []*model.Category{}
		if catMap, exists := monthCategoryMap[month]; exists {
			for _, category := range catMap {
				categories = append(categories, category)
			}
		}
		// Sort categories by ID
		sort.Slice(categories, func(i, j int) bool {
			return categories[i].ID < categories[j].ID
		})

		monthSummaries[month-1] = &model.MonthSummary{
			Month:      month,
			Categories: categories,              // Categories with transactions for this month
			Total:      groupedTotalsMap[month], // Total for this month
		}

		// Set defaults if necessary
		if monthSummaries[month-1].Categories == nil {
			monthSummaries[month-1].Categories = []*model.Category{}
		}
		if monthSummaries[month-1].Total == nil {
			monthSummaries[month-1].Total = new(float64)
			*monthSummaries[month-1].Total = 0

		}

	}

	return monthSummaries, nil
}

// Categories is the resolver for the Categories field.
func (r *queryResolver) Categories(ctx context.Context, rangeArg *model.RangeInput) ([]*model.Category, error) {
	fmt.Println("Categories: ", time.Now().Format("15:04:05"))

	userId, err := utils.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Apply date range filter if provided
	var rangeQuery *gorm.DB
	if rangeArg != nil {
		rangeQuery = r.DB.Where("transactions.date Between ? AND ?", rangeArg.StartDate, rangeArg.EndDate)
	}

	// Query categories (ALL categories)
	var categories []*model.Category
	if err := r.DB.Find(&categories).Error; err != nil {
		return nil, err
	}

	// Query transactions with totals, joined with categories
	// Querying all transactions for the user, filtering by range if provided
	query := r.DB.Table("transactions").
		Select("transactions.category_id, transactions.id AS transaction_id, transactions.amount, transactions.item, transactions.date, COALESCE(SUM(transactions.amount), 0) AS total").
		Joins("LEFT JOIN categories ON categories.id = transactions.category_id").
		Where("transactions.user_id = ?", userId).
		Group("transactions.category_id, transactions.id")

	// Apply the date range filter for transactions if provided
	if rangeQuery != nil {
		query = query.Where("transactions.date Between ? AND ?", rangeArg.StartDate, rangeArg.EndDate)
	}

	// Execute the query and get transactions with category totals
	var transactionsWithTotals []struct {
		CategoryID    int     `gorm:"column:category_id"`
		TransactionID int     `gorm:"column:transaction_id"`
		Amount        float64 `gorm:"column:amount"`
		Item          string  `gorm:"column:item"`
		Date          string  `gorm:"column:date"`
		Total         float64 `gorm:"column:total"`
	}

	if err := query.Scan(&transactionsWithTotals).Error; err != nil {
		return nil, err
	}

	// Initialize a map to store categories by their ID
	categoryMap := make(map[int]*model.Category)
	// Populate categoryMap with all categories
	for _, category := range categories {
		// Set default total to 0 if not already set
		if category.Total == nil {
			category.Total = new(float64)
		}
		// Ensure transactions is an empty array by default
		category.Transactions = []*model.Transaction{}
		categoryMap[category.ID] = category
	}

	// Map to store transactions for each category
	for _, data := range transactionsWithTotals {
		category, exists := categoryMap[data.CategoryID]
		if !exists {
			continue // Skip if no such category exists (shouldn't happen with all categories preloaded)
		}

		// Add the transaction to the category
		category.Transactions = append(category.Transactions, &model.Transaction{
			ID:       data.TransactionID,
			Amount:   data.Amount,
			Item:     data.Item,
			Date:     data.Date,
			Category: category,
		})

		// Update the total for the category
		*category.Total += data.Total
	}

	// Sort transactions by date (or any field you want)
	for _, category := range categoryMap {
		sort.Slice(category.Transactions, func(i, j int) bool {
			// Example sorting by date
			return category.Transactions[i].Date < category.Transactions[j].Date
		})
	}

	// Convert map to slice and sort categories by ID
	var finalCategories []*model.Category
	for _, category := range categoryMap {
		finalCategories = append(finalCategories, category)
	}

	// Sort categories by ID
	sort.Slice(finalCategories, func(i, j int) bool {
		return finalCategories[i].ID < finalCategories[j].ID
	})

	return finalCategories, nil
}

// Category is the resolver for the Category field.
func (r *queryResolver) Category(ctx context.Context, id int, rangeArg *model.RangeInput) (*model.Category, error) {
	category := model.Category{}

	if err := r.DB.First(&category, id).Error; err != nil {
		return nil, err
	}
	return &category, nil
}

// Years is the resolver for the Years field.
func (r *queryResolver) Years(ctx context.Context) ([]*int, error) {
	fmt.Println("Years: ", time.Now().Format("15:04:05"))

	userId, err := utils.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var years []int

	if err := r.DB.Table("distinct_years").
		Where("user_id = ?", userId).
		Select("year").
		Order("year DESC").
		Pluck("year", &years).Error; err != nil {
		return nil, err
	}

	var result []*int
	for _, year := range years {
		yearCopy := year
		result = append(result, &yearCopy)
	}

	return result, nil
}

// LastDate is the resolver for the LastDate field.
func (r *queryResolver) LastDate(ctx context.Context) (*string, error) {
	fmt.Println("LastDate: ", time.Now().Format("15:04:05"))

	userId, err := utils.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	transaction := &model.Transaction{}
	var lastDate time.Time

	if err := r.DB.Model(&transaction).Where("user_id = ?", userId).Order("date DESC").Limit(1).Pluck("date", &lastDate).Error; err != nil {
		return nil, err
	}

	if lastDate.IsZero() {
		return nil, nil
	}

	formattedDate := lastDate.Format("2006-01-02T15:04:05-0700")
	result := &formattedDate

	return result, nil
}

// Total is the resolver for the Total field.
func (r *queryResolver) Total(ctx context.Context, rangeArg *model.RangeInput) (*float64, error) {
	fmt.Println("Total: ", time.Now().Format("15:04:05"))

	userId, err := utils.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var total float64
	query := r.DB.Model(&model.Transaction{}).Where("user_id = ?", userId)

	if rangeArg != nil {
		query.Where("date Between ? AND ?", rangeArg.StartDate, rangeArg.EndDate)
	}

	if err := query.Select("COALESCE(SUM(amount), 0)").Scan(&total).Error; err != nil {
		return nil, err
	}

	return &total, nil

}

// Category is the resolver for the category field.
func (r *transactionResolver) Category(ctx context.Context, obj *model.Transaction) (*model.Category, error) {
	if obj.Category == nil {
		fmt.Println("Transactions Category: ", time.Now().Format("15:04:05"))

		category := &model.Category{}
		if err := r.DB.First(&category, obj.CategoryID).Error; err != nil {
			return nil, err
		}

		obj.Category = category
	}
	return obj.Category, nil
}

// Category returns CategoryResolver implementation.
func (r *Resolver) Category() CategoryResolver { return &categoryResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Transaction returns TransactionResolver implementation.
func (r *Resolver) Transaction() TransactionResolver { return &transactionResolver{r} }

type categoryResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type transactionResolver struct{ *Resolver }
